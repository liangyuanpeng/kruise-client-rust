// WARNING: generated by kopium - manual changes will be overwritten
// kopium command: kopium -f -
// kopium version: 0.15.0

use kube::CustomResource;
use serde::{Serialize, Deserialize};
use std::collections::BTreeMap;
use std::collections::HashMap;
use k8s_openapi::apimachinery::pkg::util::intstr::IntOrString;

#[derive(CustomResource, Serialize, Deserialize, Clone, Debug)]
#[kube(group = "apps.kruise.io", version = "v1alpha1", kind = "WorkloadSpread", plural = "workloadspreads")]
#[kube(namespaced)]
#[kube(status = "WorkloadSpreadStatus")]
#[kube(schema = "disabled")]
pub struct WorkloadSpreadSpec {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "scheduleStrategy")]
    pub schedule_strategy: Option<WorkloadSpreadScheduleStrategy>,
    pub subsets: Vec<WorkloadSpreadSubsets>,
    #[serde(rename = "targetRef")]
    pub target_ref: WorkloadSpreadTargetRef,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadScheduleStrategy {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub adaptive: Option<WorkloadSpreadScheduleStrategyAdaptive>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "type")]
    pub r#type: Option<WorkloadSpreadScheduleStrategyType>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadScheduleStrategyAdaptive {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "disableSimulationSchedule")]
    pub disable_simulation_schedule: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "rescheduleCriticalSeconds")]
    pub reschedule_critical_seconds: Option<i32>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum WorkloadSpreadScheduleStrategyType {
    Adaptive,
    Fixed,
    #[serde(rename = "")]
    KopiumEmpty,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsets {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "maxReplicas")]
    pub max_replicas: Option<IntOrString>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub patch: Option<HashMap<String, serde_json::Value>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "preferredNodeSelectorTerms")]
    pub preferred_node_selector_terms: Option<Vec<WorkloadSpreadSubsetsPreferredNodeSelectorTerms>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "requiredNodeSelectorTerm")]
    pub required_node_selector_term: Option<WorkloadSpreadSubsetsRequiredNodeSelectorTerm>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tolerations: Option<Vec<WorkloadSpreadSubsetsTolerations>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsPreferredNodeSelectorTerms {
    pub preference: WorkloadSpreadSubsetsPreferredNodeSelectorTermsPreference,
    pub weight: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsPreferredNodeSelectorTermsPreference {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<WorkloadSpreadSubsetsPreferredNodeSelectorTermsPreferenceMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<WorkloadSpreadSubsetsPreferredNodeSelectorTermsPreferenceMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsPreferredNodeSelectorTermsPreferenceMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsPreferredNodeSelectorTermsPreferenceMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsRequiredNodeSelectorTerm {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchExpressions")]
    pub match_expressions: Option<Vec<WorkloadSpreadSubsetsRequiredNodeSelectorTermMatchExpressions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "matchFields")]
    pub match_fields: Option<Vec<WorkloadSpreadSubsetsRequiredNodeSelectorTermMatchFields>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsRequiredNodeSelectorTermMatchExpressions {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsRequiredNodeSelectorTermMatchFields {
    pub key: String,
    pub operator: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<Vec<String>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadSubsetsTolerations {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub effect: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub operator: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "tolerationSeconds")]
    pub toleration_seconds: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadTargetRef {
    #[serde(rename = "apiVersion")]
    pub api_version: String,
    pub kind: String,
    pub name: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadStatus {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "observedGeneration")]
    pub observed_generation: Option<i64>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "subsetStatuses")]
    pub subset_statuses: Option<Vec<WorkloadSpreadStatusSubsetStatuses>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadStatusSubsetStatuses {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub conditions: Option<Vec<WorkloadSpreadStatusSubsetStatusesConditions>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "creatingPods")]
    pub creating_pods: Option<BTreeMap<String, String>>,
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "deletingPods")]
    pub deleting_pods: Option<BTreeMap<String, String>>,
    #[serde(rename = "missingReplicas")]
    pub missing_replicas: i32,
    pub name: String,
    pub replicas: i32,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct WorkloadSpreadStatusSubsetStatusesConditions {
    #[serde(default, skip_serializing_if = "Option::is_none", rename = "lastTransitionTime")]
    pub last_transition_time: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
    pub status: String,
    #[serde(rename = "type")]
    pub r#type: String,
}

